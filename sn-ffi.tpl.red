Red [
	comment {bg:TPL_COMMENT [TEMPLATE_FILE: "sn-ffi.tpl.red"]} "This file is generated by %bindgen.red from %sn-ffi.tpl.red" comment {bg-end:TPL_COMMENT}
]

#system [
	
	buffer!: alias struct! [
		data [byte-ptr!]
		len [integer!]
	]


	#import [

		"sn_ffi/target/i686-unknown-linux-gnu/debug/libsn_ffi.so" cdecl [
		
comment {bg:OBJ [
	NAME: "s-afe"
]}

	comment {bg:s-afe_OBJ_DEFAULT []}
			c_s-afe_default: "s-afe_default" [
				return: [int-ptr!]
			]

			c_s-afe_free: "s-afe_free" [
				ref [int-ptr!]
			]
	comment {bg-end:s-afe_OBJ_DEFAULT}

	comment {bg:s-afe_FIELD_STRING [
		FIELDNAME: "xorurl_base"
		FIELDNAME_DASH: "xorurl-base"
	]}
			c_s-afe_xorurl_base: "s-afe_xorurl_base" [
				ref [int-ptr!]
				return: [c-string!]
			]
	comment {bg-end:s-afe_FIELD_STRING}

	comment {bg:s-afe_METHOD [
		METHODNAME: "c-onnect"
	]}
			c_s-afe_c-onnect: "s-afe_c-onnect" [
				rt [int-ptr!] ;@@ TODO: async
				comment {bg:s-afe_c-onnect_SELF []} ref [int-ptr!] comment {bg-end:s-afe_c-onnect_SELF}
				params [byte-ptr!]
				params_size [integer!]
				return: [buffer!]
			]
	comment {bg-end:s-afe_METHOD}

comment {bg-end:OBJ}

			init_runtime: "init_runtime" [
				return: [int-ptr!]
			]

			cstring_free: "cstring_free" [
				ptr [c-string!]
			]
			
			buffer_free: "buffer_free" [
				buf [buffer!]
			]
		]
	]
	
	tokio_runtime: init_runtime
]



; low-level routines

sn-ffi-result: function [v] [		;; unwrap() in Rust's terms
	if all [
		paren! = type? v
		"Err" = v/1
	] [
		probe v/2/1
		do make error! v/2/2
	]
	
	either all [
		paren! = type? v
		"Ok" = v/1
	] [
		v/2
	] [
		v
	]
]

comment {bg:OBJ [
	NAME: "s-afe"
]}

comment {bg:s-afe_OBJ_DEFAULT []}
s-afe_default: routine [
	return: [integer!]
] [
	integer/box as integer! c_s-afe_default
]

s-afe_free: routine [
	ref [integer!]
] [
	c_s-afe_free ref
]
comment {bg-end:s-afe_OBJ_DEFAULT}

comment {bg:s-afe_FIELD_STRING [
	FIELDNAME: "xorurl_base"
	FIELDNAME_DASH: "xorurl-base"
]}
s-afe_xorurl_base: routine [
	ref [integer!]
	return: [string!]
	/local str buffer size
] [
	str: c_s-afe_xorurl_base as int-ptr! ref

	size: length? str
	buffer: string/load str size UTF-8

	cstring_free str

	as red-string! SET_RETURN(buffer)
]
comment {bg-end:s-afe_FIELD_STRING}

comment {bg:s-afe_METHOD [
	METHODNAME: "c-onnect"
	RETURN: "Result<(), Error>"
	RET_REF: " converted into handle!"
	RET_RESULT: " unwrapped"
]}

s-afe_c-onnect: function [
	comment {bg:s-afe_c-onnect_SELF []} ref [integer!] comment {bg-end:s-afe_c-onnect_SELF}
    comment {bg:s-afe_c-onnect_PARAM [
        PARAMNAME: "app-keypair"
        PARAMTYPE: "Option<Keypair>"
    ]} app-keypair			;; in rust: Option<Keypair>
    comment {bg-end:s-afe_c-onnect_PARAM}
    ;; returns: Result<(), Error> unwrapped converted into handle!.
] [
	params: to binary! ""
	save/as
		params
		probe reduce [comment {bg:s-afe_c-onnect_PARAM [PARAMNAME: "app-keypair"]} app-keypair comment {bg-end:s-afe_c-onnect_PARAM}]
		'redbin

	probe length? params
	probe result_buf: r_s-afe_c-onnect
		comment {bg:s-afe_c-onnect_SELF []} ref comment {bg-end:s-afe_c-onnect_SELF}
		probe params
	result: probe load/as result_buf 'redbin
	result: probe sn-ffi-result result
	comment {bg:s-afe_c-onnect_RETURN_REF []}
	result: to integer! at reverse result 5 comment {bg-end:s-afe_c-onnect_RETURN_REF}
]

r_s-afe_c-onnect: routine [
	comment {bg:s-afe_c-onnect_SELF []} ref [integer!] comment {bg-end:s-afe_c-onnect_SELF}
	params [binary!]
	return: [binary!]		;-- redbin-encoded Result<usize, ErrorString> or Result<T, ErrorString>
	/local buffer ret
] [
	print [tokio_runtime "^/"]
	comment {bg:s-afe_c-onnect_SELF []} print [as int-ptr! ref "^/"] comment {bg-end:s-afe_c-onnect_SELF}
	print [binary/rs-head params "^/"]
	print [binary/rs-length? params "^/"]

	buffer: c_s-afe_c-onnect
		tokio_runtime ;@@ TODO: async
		comment {bg:s-afe_c-onnect_SELF []} as int-ptr! ref comment {bg-end:s-afe_c-onnect_SELF}
		binary/rs-head params
		binary/rs-length? params
	print ["buffer: " buffer "^/"]
	print ["buffer data: " buffer/data "^/"]
	print ["buffer len: " buffer/len "^/"]
	
	ret: binary/load buffer/data buffer/len
	print ["ret: " ret "^/"]

	buffer_free buffer
	as red-binary! SET_RETURN(ret)
]
comment {bg-end:s-afe_METHOD}

comment {bg-end:OBJ}


; hi-level code

to-vec-u8: function [
	key-bin [binary!]
	return: [block!]
] [
	key: copy []
	foreach b key-bin [
		append key b
	]
	reduce [key]
]


comment {bg:OBJ [
	NAME: "s-afe"
]}
s-afe!: object [
	ref: none

	comment {bg:s-afe_OBJ_DEFAULT []}
	init: does [
		ref: s-afe_default
	]

	free: does [
		s-afe_free ref
		ref: none
	]
	comment {bg-end:s-afe_OBJ_DEFAULT}

	comment {bg:s-afe_FIELD_STRING [
		FIELDNAME: "xorurl_base"
		FIELDNAME_DASH: "xorurl-base"
	]}
	xorurl-base: does [
		s-afe_xorurl_base ref
	]
	comment {bg-end:s-afe_FIELD_STRING}
	
	comment {bg:s-afe_METHOD [
		METHODNAME: "c-onnect"
		RETURN: "Result<(), Error>"
	]}
	c-onnect: function [
	    comment {bg:s-afe_c-onnect_PARAM [
	        PARAMNAME: "app-keypair"
	        PARAMTYPE: "Option<Keypair>"
	    ]} app-keypair			;; in rust: Option<Keypair>
	    comment {bg-end:s-afe_c-onnect_PARAM}
	    ;; returns: Result<(), Error>
	] [
		s-afe_c-onnect
			comment {bg:s-afe_c-onnect_SELF []} ref comment {bg-end:s-afe_c-onnect_SELF}
			comment {bg:s-afe_c-onnect_PARAM [PARAMNAME: "app-keypair"]} app-keypair
			comment {bg-end:s-afe_c-onnect_PARAM}
	]
	comment {bg-end:s-afe_METHOD}

]
comment {bg-end:OBJ}


safe: object [
	ref: none
	test: none

	
	init: does [
		probe "init"
; 		ref: safe_default
; 		print ref
		test: null-handle
		print test
	]
	
	connect: function [
	     peers			;; in rust: Vec<Multiaddr>
	     add_network_peers			;; in rust: bool
	     secret			;; in rust: Option<SecretKey>
	    
	    ;; returns: Result<(), Error>
	] [
		probe "connect"
; 		print self/ref
; 		print ref
; 		print self/test
		safe_connect
; 			 self/ref 
			 peers
			 add_network_peers
			 secret
			 "TRACE"
			
	]

]


build-xorname: function [
	from [word! binary! string!]	; use word `random as good practice
	names [block!]					; block of strings and binaries
	return: [binary!]				; xorname
] [
	builder-ref: switch type? from [
		word! [ xornamebuilder_random ]
		binary! [ xornamebuilder_from from ]
		string! [ xornamebuilder_from_str from ]
	]

	foreach name names [
		switch type? name [
			binary! [ xornamebuilder_with_bytes builder-ref name ]
			string! [ xornamebuilder_with_str builder-ref name ]
		]
	]

	xornamebuilder_build builder-ref
]

/*bg:TPL_COMMENT [TEMPLATE_FILE: "lib.tpl.rs"]*/
//***
//* This file is generated by bindgen.red from lib.tpl.rs
//*** /*bg-end:TPL_COMMENT*/

use std::fmt;
use std::ffi::{CString, c_char};
use std::convert::TryInto;
use tokio::runtime::Runtime;
use redbin::{from_bytes as from_redbin, to_bytes as to_redbin};
use serde::Serialize;

use safe::{SecretKey, Multiaddr, XorName};

/*bg:API_IMPORT [MOD:"sn_api::" NAME: "Safe"]*/
use sn_api::Safe;/*bg-end:API_IMPORT*/


#[repr(C)]
#[derive(Debug)]
pub struct Buffer {
	data: *mut u8,
	len: usize,
}

#[derive(Serialize)]
struct ErrorString(String, String);

impl fmt::Debug for ErrorString {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		self.0.fmt(f)
	}
}

/*bg:OBJ_DEFAULT [
    NAME: "Safe"
    LOWNAME: "s_afe"
]*/
#[no_mangle]
pub extern "C" fn s_afe_default() -> *mut Safe {
    Box::into_raw(Box::new(Safe::default()))
}

/*bg-end:OBJ_DEFAULT*/
/*bg:OBJ [
    NAME: "Safe"
    LOWNAME: "s_afe"
]*/
#[no_mangle]
pub extern "C" fn s_afe_free(ptr: *mut Safe) {
    if ptr.is_null() {
        return;
    }
    unsafe {
        let _ = Box::from_raw(ptr);
    }
}
/*bg-end:OBJ*/


/*bg:FIELD_STRING [
    NAME: "Safe"
    LOWNAME: "s_afe"
    FIELDNAME: "xorurl_base"
]*/
#[no_mangle]
pub extern "C" fn s_afe_xorurl_base(ptr: *const Safe) -> *mut c_char {
    assert!(!ptr.is_null());
    let s_afe = unsafe {
        &*ptr
    };

    let xorurl_base = CString::new(s_afe.xorurl_base.to_string()).expect("Could not convert to CString");
    xorurl_base.into_raw()
}
/*bg-end:FIELD_STRING*/


/*bg:METHOD [
    NAME: "Safe"
    LOWNAME: "s_afe"
    METHODNAME: "connect"
    RETURN: "Result<(), Error>"
]*/
#[no_mangle]
pub extern "C" fn s_afe_connect(
	/*bg:s_afe_connect_ASYNC []*/rt_ptr: *mut Runtime,/*bg-end:s_afe_connect_ASYNC*/
	/*bg:s_afe_connect_SELF []*/s_afe_ptr: *mut Safe,/*bg-end:s_afe_connect_SELF*/
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    /*bg:s_afe_connect_ASYNC []*/println!("rt_ptr: {:?}", rt_ptr);/*bg-end:s_afe_connect_ASYNC*/
    /*bg:s_afe_connect_SELF []*/println!("s_afe_ptr: {:?}", s_afe_ptr);/*bg-end:s_afe_connect_SELF*/
    println!("s_afe_connect params pointer: {:?}, size: {:?} / {:x}", params, params_size, params_size);

    /*bg:s_afe_connect_ASYNC []*/assert!(!rt_ptr.is_null());/*bg-end:s_afe_connect_ASYNC*/
    /*bg:s_afe_connect_SELF []*/assert!(!s_afe_ptr.is_null());/*bg-end:s_afe_connect_SELF*/
    
    let params: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };
    println!("s_afe_connect u8: {:?}", params);

    let params: (
    /*bg:s_afe_connect_PARAM [
        PARAMNAME: "app_keypair"
        PARAMTYPE: "Option<Keypair>"
    ]*/
        Option<Keypair>, // app_keypair /*bg-end:s_afe_connect_PARAM*/
    ) = from_redbin(params).map_err(|e| { eprintln!("cannot deserialize: {:?}", e); e }).unwrap();
    println!("s_afe_connect params: {:?}", params);

    let ret = unsafe { // Result<(), Error>
        /*bg:s_afe_connect_SELF [ SELF_PTR: "&mut " ]*/let s_afe = &mut std::ptr::read(s_afe_ptr);/*bg-end:s_afe_connect_SELF*/
        /*bg:s_afe_connect_ASYNC []*/
        let rt = &mut *rt_ptr;
        rt.block_on(/*bg-end:s_afe_connect_ASYNC*/
        	Safe::connect(/*bg:s_afe_connect_SELF []*/s_afe/*bg-end:s_afe_connect_SELF*//*bg:s_afe_connect_PARAM [PARAMNUM: "0" COMMA: ", " BORROW: "&"]*/, &params.0/*bg-end:s_afe_connect_PARAM*/)
        /*bg:s_afe_connect_ASYNC []*/
        )/*bg-end:s_afe_connect_ASYNC*/
    };
    /*bg:s_afe_connect_RETURN_RESULT []*/
    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
    /*bg-end:s_afe_connect_RETURN_RESULT*/
    /*bg:s_afe_connect_RETURN_REF_RESULT []*/
    let ret: Result<usize, ErrorString> = ret.map(|value| Box::into_raw(Box::new(value)) as usize);
    /*bg-end:s_afe_connect_RETURN_REF_RESULT*/
    /*bg:s_afe_connect_RETURN_REF []*/
    let ret: usize = Box::into_raw(Box::new(ret)) as usize;
    /*bg-end:s_afe_connect_RETURN_REF*/
    println!("s_afe_connect ret: {:?}", &ret);
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
    println!("s_afe_connect ret_bytes: {}", hex::encode_upper(&ret_bytes));
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}
/*bg-end:METHOD*/

#[no_mangle]
pub extern "C" fn init_runtime() -> *mut Runtime {
//	let rt: Runtime = Builder::new_current_thread().build().unwrap(); // TODO: try with single thread
    Box::into_raw(Box::new(Runtime::new().unwrap()))
}

#[no_mangle]
pub extern "C" fn cstring_free(cstring: *mut c_char) {
    if cstring.is_null() {
        return;
    }
    unsafe {
        let _ = CString::from_raw(cstring);
    }
}

#[no_mangle]
pub extern "C" fn buffer_free(buf: *mut Buffer) {
	let buf = unsafe {
		assert!(!buf.is_null());
		&mut *buf
	};
	println!("buffer_free buf: {:?}", buf);

	let b: &mut [u8] = unsafe { std::slice::from_raw_parts_mut(buf.data, buf.len) };
	unsafe {
		let _ = Box::from_raw(b.as_mut_ptr());
	}
}

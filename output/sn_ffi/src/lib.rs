
//***
//* This file is generated by bindgen.red from sn_ffi/src/lib.tpl.rs
//*** 

use std::ffi::{CString, c_char};
use tokio::runtime::Runtime;
use bls::SecretKey;
use libp2p::PeerId;
use redbin::{from_bytes as from_redbin, to_bytes as to_redbin};
use serde::Serialize;


use safe::Safe;


#[repr(C)]
pub struct Buffer {
	data: *mut u8,
	len: usize,
}

#[derive(Serialize)]
struct ErrorString(String, String);


#[no_mangle]
pub extern "C" fn safe_default() -> *mut Safe {
    Box::into_raw(Box::new(Safe::default()))
}

#[no_mangle]
pub extern "C" fn safe_free(ptr: *mut Safe) {
    if ptr.is_null() {
        return;
    }
    unsafe {
        Box::from_raw(ptr);
    }
}







#[no_mangle]
pub extern "C" fn safe_connect(
	
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> Buffer {
    println!("safe_connect pointer: {:?}, size: {:?}", params, params_size);

    
    assert!(!safe_ptr.is_null());
    
    let params: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size) };
    println!("safe_connect u8: {:?}", params);

    let params: (
    
        Vec<String>, // peers 
        Option<String>, // secret 
    ) = from_redbin(params).unwrap();
    println!("safe_connect params: {:?}", params);

    let ret = unsafe { // Result<Option<String>, Error>
        let safe = &mut *safe_ptr;
        
        	Safe::connect(safe, params.0, params.1)
        
    };
    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);
	return Buffer { data, len };
}


#[no_mangle]
pub extern "C" fn init_runtime() -> *mut Runtime {
	let rt: Runtime = Runtime::new().unwrap();
//	let rt: Runtime = Builder::new_current_thread().build().unwrap(); // TODO: try with single thread
    Box::into_raw(Box::new(Runtime::new().unwrap()))
}

#[no_mangle]
pub extern "C" fn cstring_free(cstring: *mut c_char) {
    if cstring.is_null() {
        return;
    }
    unsafe {
        CString::from_raw(cstring);
    }
}

#[no_mangle]
pub extern "C" fn buffer_free(buf: Buffer) {
	let b: &mut [u8] = unsafe { std::slice::from_raw_parts_mut(buf.data, buf.len) };
	unsafe {
		Box::from_raw(b.as_mut_ptr());
	}
}

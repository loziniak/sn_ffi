
//***
//* This file is generated by bindgen.red from sn_ffi/src/lib.tpl.rs
//*** 

use std::fmt;
use std::ffi::{CString, c_char};
use std::convert::TryInto;
use tokio::runtime::Runtime;
use redbin::{from_bytes as from_redbin, to_bytes as to_redbin};
use serde::Serialize;

use safe::{SecretKey, Multiaddr, XorName};


use safe::Safe;


#[repr(C)]
#[derive(Debug)]
pub struct Buffer {
	data: *mut u8,
	len: usize,
}

#[derive(Serialize)]
struct ErrorString(String, String);

impl fmt::Debug for ErrorString {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		self.0.fmt(f)
	}
}



#[no_mangle]
pub extern "C" fn safe_free(ptr: *mut Safe) {
    if ptr.is_null() {
        return;
    }
    unsafe {
        let _ = Box::from_raw(ptr);
    }
}







#[no_mangle]
pub extern "C" fn safe_address(
	
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<EvmAddress, Error>
		        let safe = &mut *safe_ptr;
		        
		        	Safe::address(safe)
		        
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_balance(
	rt_ptr: *mut Runtime,
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    assert!(!rt_ptr.is_null());
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<(U256, U256), Error>
		        let safe = &mut *safe_ptr;
		        
		        let rt = &mut *rt_ptr;
		        rt.block_on({
		        	Safe::balance(safe)
		        
		        })
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_connect(
	rt_ptr: *mut Runtime,
	
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    assert!(!rt_ptr.is_null());
    
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        Vec<Multiaddr>, // peers 
        bool, // add_network_peers 
        Option<SecretKey>, // secret 
        String, // log_level 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<Safe, Error>
		        
		        
		        let rt = &mut *rt_ptr;
		        rt.block_on({
		        	Safe::connect(params_de.0, params_de.1, params_de.2, params_de.3)
		        
		        })
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    let ret: Result<usize, ErrorString> = ret.map(|value| Box::into_raw(Box::new(value)) as usize);
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_download(
	rt_ptr: *mut Runtime,
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    assert!(!rt_ptr.is_null());
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        XorName, // xorname 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<Vec<u8>, Error>
		        let safe = &mut *safe_ptr;
		        
		        let rt = &mut *rt_ptr;
		        rt.block_on({
		        	Safe::download(safe, params_de.0)
		        
		        })
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_login(
	
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        Option<SecretKey>, // secret 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<(), Error>
		        let safe = &mut *safe_ptr;
		        
		        	Safe::login(safe, params_de.0)
		        
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_login_with_eth(
	
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        Option<String>, // eth_privkey 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<(), Error>
		        let safe = &mut *safe_ptr;
		        
		        	Safe::login_with_eth(safe, params_de.0)
		        
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_log_level(
	
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        String, // level 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<(), Error>
		        let safe = &mut *safe_ptr;
		        
		        	Safe::log_level(safe, params_de.0)
		        
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_read_reg(
	rt_ptr: *mut Runtime,
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    assert!(!rt_ptr.is_null());
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        XorName, // meta 
        Option<u32>, // version 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<Vec<u8>, Error>
		        let safe = &mut *safe_ptr;
		        
		        let rt = &mut *rt_ptr;
		        rt.block_on({
		        	Safe::read_reg(safe, &params_de.0, params_de.1)
		        
		        })
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_reg_create(
	rt_ptr: *mut Runtime,
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    assert!(!rt_ptr.is_null());
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        &[u8], // data 
        XorName, // meta 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<(), Error>
		        let safe = &mut *safe_ptr;
		        
		        let rt = &mut *rt_ptr;
		        rt.block_on({
		        	Safe::reg_create(safe, params_de.0, &params_de.1)
		        
		        })
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_reg_write(
	rt_ptr: *mut Runtime,
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    assert!(!rt_ptr.is_null());
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        &[u8], // data 
        XorName, // meta 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<(), Error>
		        let safe = &mut *safe_ptr;
		        
		        let rt = &mut *rt_ptr;
		        rt.block_on({
		        	Safe::reg_write(safe, params_de.0, &params_de.1)
		        
		        })
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}

#[no_mangle]
pub extern "C" fn safe_upload(
	rt_ptr: *mut Runtime,
	safe_ptr: *mut Safe,
	params: *const u8,
	params_size: usize,
) -> *mut Buffer {
    assert!(!rt_ptr.is_null());
    assert!(!safe_ptr.is_null());
    
    let params_slice: &[u8] = unsafe { std::slice::from_raw_parts(params, params_size.try_into().unwrap()) };

    let params_res: Result<(
    
        &[u8], // data 
    ), ErrorString> = from_redbin(params_slice).map_err(|e| ErrorString(format!("Cannot deserialize params. {:?}", e), format!("Cannot deserialize params. {}", e)));

    let ret = match params_res {
    	Ok(params_de) => {
    		let ret = unsafe { // Result<XorName, Error>
		        let safe = &mut *safe_ptr;
		        
		        let rt = &mut *rt_ptr;
		        rt.block_on({
		        	Safe::upload(safe, params_de.0)
		        
		        })
		    };
		    
		    let ret = ret.map_err(|err| ErrorString(format!("{:?}", err), format!("{}", err)));
		    
		    
		    ret
	    }
	    Err(es) => Err(es)
    };
    
	let mut ret_bytes: Vec<u8> = to_redbin(&ret).unwrap();
	let data = ret_bytes.as_mut_ptr();
	let len = ret_bytes.len();
	std::mem::forget(ret_bytes);

	Box::into_raw(Box::new(Buffer { data, len }))
}


#[no_mangle]
pub extern "C" fn init_runtime() -> *mut Runtime {
//	let rt: Runtime = Builder::new_current_thread().build().unwrap(); // TODO: try with single thread
    Box::into_raw(Box::new(Runtime::new().unwrap()))
}

#[no_mangle]
pub extern "C" fn cstring_free(cstring: *mut c_char) {
    if cstring.is_null() {
        return;
    }
    unsafe {
        let _ = CString::from_raw(cstring);
    }
}

#[no_mangle]
pub extern "C" fn buffer_free(buf: *mut Buffer) {
	let buf = unsafe {
		assert!(!buf.is_null());
		&mut *buf
	};

	let b: &mut [u8] = unsafe { std::slice::from_raw_parts_mut(buf.data, buf.len) };
	unsafe {
		let _ = Box::from_raw(b.as_mut_ptr());
	}
}
